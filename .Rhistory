library(stars)
# Read raster
Refl <- brick(Refl_path)
# get raster band name and clean format. Expecting band name and wavelength to be documented in image
HDR_Refl <- read_ENVI_header(get_HDR_name(Refl_path))
SensorBands <- HDR_Refl$wavelength
# compute a set of spectral indices defined by IndexList from S2 data
IndexList <- c('EVI','NDVI','CR_SWIR', 'MCARI','NDWI1','mNDVI705')
# ReflFactor = 10000 when reflectance is coded as INT16
Indices <- prosail::ComputeSpectralIndices_Raster(Refl = Refl, SensorBands = SensorBands,
Sel_Indices = IndexList,
ReflFactor = 10000, StackOut=F)
# create directory for Spectral indices
SI_path <- file.path(results_site_path,'SpectralIndices')
dir.create(path = SI_path,showWarnings = FALSE,recursive = TRUE)
# Save spectral indices
for (SpIndx in names(Indices$SpectralIndices)){
Index_Path <- file.path(SI_path,paste(basename(S2obj$S2_Bands$GRANULE),'_',SpIndx,sep = ''))
stars::write_stars(st_as_stars(Indices$SpectralIndices[[SpIndx]]), dsn=Index_Path, driver =  "ENVI",type='Float32')
# write band name in HDR
HDR <- read_ENVI_header(get_HDR_name(Index_Path))
HDR$`band names` <- SpIndx
write_ENVI_header(HDR = HDR,HDRpath = get_HDR_name(Index_Path))
}
S2obj$S2_Stack[['Cloud']]
NDVI_Thresh <- 0.5
Elim <- which(Indices$SpectralIndices$NDVI>NDVI_Thresh)
Indices$SpectralIndices$NDVI
Elim <- which(Indices$SpectralIndices$NDVI[[1]]>NDVI_Thresh)
Elim <- which(Indices$SpectralIndices$NDVI$layer[[1]]>NDVI_Thresh)
Indices$SpectralIndices$NDVI
Indices$SpectralIndices[['NDVI']][1]
Indices$SpectralIndices[['NDVI']][[1]]
values(Indices$SpectralIndices[['NDVI']])
NDVI_Thresh <- 0.5
Elim <- which(values(Indices$SpectralIndices[['NDVI']])>NDVI_Thresh)
S2obj$S2_Stack[['Cloud']][Elim] <- 0
Cloud_path
Cloud_File <- file.path(Cloud_path,'CloudMask_Binary_Update')
WhichCloud
WhichCloud <- which(names(S2obj$S2_Stack)=="Cloud")
WhichCloud
stars::write_stars(S2obj$S2_Stack, dsn=Cloud_File,layer=WhichCloud, driver = "ENVI",type='Byte')
NDVI_Thresh
S2obj <- preprocS2::extract_from_S2_L2A(Path_dir_S2 = Path_S2,
path_vector = path_vector,
S2source = S2source,
resolution = resolution)
Cloud_path <- file.path(results_site_path,'CloudMask')
dir.create(path = Cloud_path,showWarnings = FALSE,recursive = TRUE)
# Filename for cloud mask
cloudmasks <- preprocS2::save_cloud_s2(S2_stars = S2obj$S2_Stack,
Cloud_path = Cloud_path,
S2source = S2source, SaveRaw = T)
CloudInit <- stars::read_stars(cloudmasks$BinaryMask)
NDVI_Thresh <- 0.5
Elim <- which(values(Indices$SpectralIndices[['NDVI']])<NDVI_Thresh)
CloudInit
CloudInit$CloudMask_Binary[Elim] <- 0
Cloud_File <- file.path(Cloud_path,'CloudMask_Binary_Update')
stars::write_stars(CloudInit, dsn=Cloud_File,driver = "ENVI",type='Byte')
# get S2 geometry
# read metadata file from S2 image
xmlfile <- file.path(dirname(Refl_path),'MTD_TL.xml')
S2Geom <- get_S2geometry(MTD_TL_xml = xmlfile)
# Train PROSAIL inversion
minval <- data.frame('CHL'=10,'CAR'=0,'EWT' = 0.005,'ANT' = 0,'LMA' = 0.005,'N' = 1.5,'psoil' = 0.0, 'BROWN'=0.0,
'LIDFa' = 50, 'lai' = 0.5,'q'=0.1,'tto' = 0,'tts' = min(S2Geom$SZA), 'psi' = 5)
maxval <- data.frame('CHL'=90,'CAR'=20,'EWT' = 0.03,'ANT' = 3,'LMA' = 0.03,'N' = 2.0, 'psoil' = 1.0, 'BROWN'=0.5,
'LIDFa' = 70, 'lai' = 7,'q'=0.2,'tto' = 7,'tts' = max(S2Geom$SZA), 'psi' = 355)
# get sensor response for Sentinel-2
SensorName <- HDR_Refl$`sensor type`
SRF <- GetRadiometry(SensorName,Path_SensorResponse = NULL)
# adjust optical constants from 1nm sampling into spectral S2 spectral sampling
wvl <- SpecPROSPECT$lambda
SpecSensor <- PrepareSensorSimulation(SpecPROSPECT,SpecSOIL,SpecATM,SRF)
SpecPROSPECT_Sensor <- SpecSensor[[1]]$SpecPROSPECT_Sensor
SpecSOIL_Sensor <- SpecSensor[[1]]$SpecSOIL_Sensor
SpecATM_Sensor <- SpecSensor[[1]]$SpecATM_Sensor
# define spectral bands required to train SVR model for each variable
S2BandSelect <- list()
S2BandSelect$CHL <- S2BandSelect$lai <- S2BandSelect$EWT <- S2BandSelect$LMA <- c('B03','B04','B05','B06','B07','B08','B11','B12')
ImgBandNames <- strsplit(HDR_Refl$`band names`,split = ',')[[1]]
# get variable ID for train_prosail_inversion
Bands2Select <- list()
for (bpvar in names(S2BandSelect)){
Bands2Select[[bpvar]] <- match(S2BandSelect[[bpvar]],ImgBandNames)
}
# define noise level for each variable
NoiseLevel <- list()
NoiseLevel$EWT <- 0.025
NoiseLevel$CHL <- 0.01
NoiseLevel$LMA <- NoiseLevel$lai <- 0.05
# where results will be stored
PROSAIL_ResPath <- file.path(results_site_path,'PROSAIL_INVERSION_4SAIL')
dir.create(path = PROSAIL_ResPath,showWarnings = FALSE,recursive = TRUE)
modelSVR <- train_prosail_inversion(minval=minval,maxval=maxval,Parms2Estimate=c('CHL','EWT','LMA','lai'),
Bands2Select=Bands2Select,NoiseLevel=NoiseLevel,
SpecPROSPECT = SpecPROSPECT_Sensor, SpecSOIL = SpecSOIL_Sensor, SpecATM = SpecATM_Sensor,
Path_Results=PROSAIL_ResPath,nbModels = 10,nbSamples = 1000,FigPlot = FALSE)
# Apply SVR model on Sentinel-2 data
Apply_prosail_inversion(raster_path = Refl_path, HybridModel = modelSVR, PathOut = PROSAIL_ResPath,
SelectedBands = S2BandSelect,bandname = ImgBandNames,
MaskRaster = Cloud_File, MultiplyingFactor = 10000)
Bands2Select
SpecPROSPECT_Sensor
Path_Results
modelSVR
modelSVR <- train_prosail_inversion(minval=minval,maxval=maxval,Parms2Estimate=c('CHL','EWT','LMA','lai'),
Bands2Select=Bands2Select,NoiseLevel=NoiseLevel,
SpecPROSPECT = SpecPROSPECT_Sensor, SpecSOIL = SpecSOIL_Sensor, SpecATM = SpecATM_Sensor,
Path_Results=PROSAIL_ResPath,nbModels = 10,nbSamples = 1000,FigPlot = FALSE)
S2BandSelect
minval
maxval
PROSAIL_ResPath
SpecPROSPECT_Sensor
ImgBandNames
S2BandSelect
match(S2BandSelect[[bpvar]],ImgBandNames)
# get S2 geometry
# read metadata file from S2 image
xmlfile <- file.path(dirname(Refl_path),'MTD_TL.xml')
S2Geom <- get_S2geometry(MTD_TL_xml = xmlfile)
# Train PROSAIL inversion
minval <- data.frame('CHL'=10,'CAR'=0,'EWT' = 0.005,'ANT' = 0,'LMA' = 0.005,'N' = 1.5,'psoil' = 0.0, 'BROWN'=0.0,
'LIDFa' = 50, 'lai' = 0.5,'q'=0.1,'tto' = 0,'tts' = min(S2Geom$SZA), 'psi' = 5)
maxval <- data.frame('CHL'=90,'CAR'=20,'EWT' = 0.03,'ANT' = 3,'LMA' = 0.03,'N' = 2.0, 'psoil' = 1.0, 'BROWN'=0.5,
'LIDFa' = 70, 'lai' = 7,'q'=0.2,'tto' = 7,'tts' = max(S2Geom$SZA), 'psi' = 355)
# get sensor response for Sentinel-2
SensorName <- HDR_Refl$`sensor type`
SRF <- GetRadiometry(SensorName,Path_SensorResponse = NULL)
wvl <- SpecPROSPECT$lambda
SpecSensor <- PrepareSensorSimulation(SpecPROSPECT,SpecSOIL,SpecATM,SRF)
SpecPROSPECT_Sensor <- SpecSensor[[1]]$SpecPROSPECT_Sensor
SpecSOIL_Sensor <- SpecSensor[[1]]$SpecSOIL_Sensor
SpecATM_Sensor <- SpecSensor[[1]]$SpecATM_Sensor
S2BandSelect <- list()
S2BandSelect$CHL <- S2BandSelect$lai <- S2BandSelect$EWT <- S2BandSelect$LMA <- c('B03','B04','B05','B06','B07','B08','B11','B12')
ImgBandNames <- strsplit(HDR_Refl$`band names`,split = ',')[[1]]
# get variable ID for train_prosail_inversion
Bands2Select <- list()
for (bpvar in names(S2BandSelect)){
Bands2Select[[bpvar]] <- match(S2BandSelect[[bpvar]],ImgBandNames)
}
Bands2Select
# define noise level for each variable
NoiseLevel <- list()
NoiseLevel$EWT <- 0.025
NoiseLevel$CHL <- 0.01
NoiseLevel$LMA <- NoiseLevel$lai <- 0.05
PROSAIL_ResPath <- file.path(results_site_path,'PROSAIL_INVERSION_4SAIL')
dir.create(path = PROSAIL_ResPath,showWarnings = FALSE,recursive = TRUE)
modelSVR <- train_prosail_inversion(minval=minval,maxval=maxval,Parms2Estimate=c('CHL','EWT','LMA','lai'),
Bands2Select=Bands2Select,NoiseLevel=NoiseLevel,
SpecPROSPECT = SpecPROSPECT_Sensor, SpecSOIL = SpecSOIL_Sensor, SpecATM = SpecATM_Sensor,
Path_Results=PROSAIL_ResPath,nbModels = 10,nbSamples = 1000,FigPlot = FALSE)
Bands2Select
minval
maxval
Parms2Estimate=c('CHL','EWT','LMA','lai')
SpecPROSPECT = SpecPROSPECT_Sensor
SpecSOIL = SpecSOIL_Sensor
SpecATM = SpecATM_Sensor
Path_Results=PROSAIL_ResPath
nbModels = 10
nbSamples = 1000
FigPlot = FALSE
Path_Results
Force4LowLAI = TRUE
SpecATM
Bands2Select
SAILversion
SAILversion='4SAIL'
nbSamplesPerRun
nbSamplesPerRun=100
Replacement
Replacement=TRUE
ParmSet
ParmSet=NULL
TypeDistrib
TypeDistrib=NULL
GaussianDistrib= NULL
nbSamples
nbSamplesPerRun
nbModels
Replacement
SpecPROSPECT
### == == == == == == == == == == == == == == == == == == == == == == ###
# Define sensor characteristics
if (is.null(SpecPROSPECT)){
SpecPROSPECT <- prosail::SpecPROSPECT
}
if (is.null(SpecSOIL)){
SpecSOIL <- prosail::SpecSOIL
}
if (is.null(SpecPROSPECT)){
SpecATM <- prosail::SpecATM
}
# define distribution for parameters to be sampled
if (is.null(TypeDistrib)){
TypeDistrib <- data.frame('CHL'='Uniform', 'CAR'='Uniform','EWT' = 'Uniform','ANT' = 'Uniform','LMA' = 'Uniform','N' = 'Uniform', 'BROWN'='Uniform',
'psoil' = 'Uniform','LIDFa' = 'Uniform', 'lai' = 'Uniform','q'='Uniform','tto' = 'Uniform','tts' = 'Uniform', 'psi' = 'Uniform')
}
if (is.null(GaussianDistrib)){
GaussianDistrib <- list('Mean'=NULL,'Std'=NULL)
}
if (is.null(minval)){
minval <- data.frame('CHL'=10,'CAR'=0,'EWT' = 0.01,'ANT' = 0,'LMA' = 0.005,'N' = 1.0,'psoil' = 0.0, 'BROWN'=0.0,
'LIDFa' = 20, 'lai' = 0.5,'q'=0.1,'tto' = 0,'tts' = 20, 'psi' = 80)
}
if (is.null(maxval)){
maxval <- data.frame('CHL'=75,'CAR'=15,'EWT' = 0.03,'ANT' = 2,'LMA' = 0.03,'N' = 2.0, 'psoil' = 1.0, 'BROWN'=0.5,
'LIDFa' = 70, 'lai' = 7,'q'=0.2,'tto' = 5,'tts' = 30, 'psi' = 110)
}
# define min and max values
# fixed parameters
if (is.null(ParmSet)){
ParmSet <- data.frame('TypeLidf' = 2, 'alpha' = 40)
}
if (SAILversion=='4SAIL'){
InputPROSAIL <- get_distribution_input_prosail(minval,maxval,ParmSet,nbSamples,
TypeDistrib = TypeDistrib,
Mean = GaussianDistrib$Mean,Std = GaussianDistrib$Std,
Force4LowLAI = Force4LowLAI)
} else if (SAILversion=='4SAIL2'){
InputPROSAIL <- get_distribution_input_prosail2(minval,maxval,ParmSet,nbSamples,
TypeDistrib = TypeDistrib,
Mean = GaussianDistrib$Mean,Std = GaussianDistrib$Std,
Force4LowLAI = Force4LowLAI)
}
InputPROSAIL
if (SAILversion=='4SAIL2'){
# Definition of Cv & update LAI
MaxLAI <- min(c(maxval$lai),4)
InputPROSAIL$Cv <- NA*InputPROSAIL$lai
InputPROSAIL$Cv[which(InputPROSAIL$lai>MaxLAI)] <- 1
InputPROSAIL$Cv[which(InputPROSAIL$lai<=MaxLAI)] <- (1/MaxLAI)+InputPROSAIL$lai[which(InputPROSAIL$lai<=MaxLAI)]/(MaxLAI+1)
InputPROSAIL$Cv <- InputPROSAIL$Cv*matrix(rnorm(length(InputPROSAIL$Cv),mean = 1,sd = 0.1))
InputPROSAIL$Cv[which(InputPROSAIL$Cv<0)] <- 0
InputPROSAIL$Cv[which(InputPROSAIL$Cv>1)] <- 1
InputPROSAIL$Cv[which(InputPROSAIL$lai>MaxLAI)] <- 1
InputPROSAIL$fraction_brown <- 0+0*InputPROSAIL$lai
InputPROSAIL$diss <- 0+0*InputPROSAIL$lai
InputPROSAIL$Zeta <- 0.2+0*InputPROSAIL$lai
InputPROSAIL$lai <- InputPROSAIL$lai*InputPROSAIL$Cv
}
# generate LUT of BRF corresponding to InputPROSAIL, for a sensor
BRF_LUT <- Generate_LUT_BRF(SAILversion=SAILversion,InputPROSAIL = InputPROSAIL,
SpecPROSPECT = SpecPROSPECT,SpecSOIL = SpecSOIL,SpecATM = SpecATM)
BRF_LUT
dim(BRF_LUT)
# write parameters LUT
output <- matrix(unlist(InputPROSAIL), ncol = length(InputPROSAIL), byrow = FALSE)
filename <- file.path(Path_Results,'PROSAIL_LUT_InputParms.txt')
write.table(x = format(output, digits=3),file = filename,append = F, quote = F,
col.names = names(InputPROSAIL), row.names = F,sep = '\t')
filename <- file.path(Path_Results,'PROSAIL_LUT_Reflectance.txt')
write.table(x = format(t(BRF_LUT), digits=5),file = filename,append = F, quote = F,
col.names = SpecPROSPECT$lambda, row.names = F,sep = '\t')
(is.null(Bands2Select))
if (is.null(NoiseLevel)){
NoiseLevel <- list()
for (parm in Parms2Estimate){
NoiseLevel[[parm]] <- 0.01
}
}
# produce LIT with noise
BRF_LUT_Noise <- list()
for (parm in Parms2Estimate){
BRF_LUT_Noise[[parm]] <- BRF_LUT[Bands2Select[[parm]],]+BRF_LUT[Bands2Select[[parm]],]*matrix(rnorm(nrow(BRF_LUT[Bands2Select[[parm]],])*ncol(BRF_LUT[Bands2Select[[parm]],]),
0,NoiseLevel[[parm]]),nrow = nrow(BRF_LUT[Bands2Select[[parm]],]))
}
modelSVR = list()
for (parm in Parms2Estimate){
ColParm <- which(parm==names(InputPROSAIL))
InputVar <- InputPROSAIL[[ColParm]]
modelSVR[[parm]] <- PROSAIL_Hybrid_Train(BRF_LUT = BRF_LUT_Noise[[parm]],InputVar = InputVar,
FigPlot = FigPlot,nbEnsemble = nbModels,WithReplacement=Replacement)
}
BRF_LUT = BRF_LUT_Noise[[parm]]
InputVar
nbEnsemble = nbModels
WithReplacement=Replacement
x <- y <- ymean <- ystdmin <- ystdmax <- NULL
# library(dplyr)
# split the LUT into nbEnsemble subsets
nbSamples <- length(InputVar)
if (dim(BRF_LUT)[2]==nbSamples){
BRF_LUT <- t(BRF_LUT)
}
# if subsets are generated from BRF_LUT with replacement
if (WithReplacement==TRUE){
Subsets <- list()
samples_per_run <- round(nbSamples/nbEnsemble)
for (run in (1:nbEnsemble)){
Subsets[[run]] <- sample(seq(1,nbSamples), samples_per_run, replace = TRUE)
}
# if subsets are generated from BRF_LUT without replacement
} else if (WithReplacement==FALSE){
Subsets <- split(sample(seq(1,nbSamples,by = 1)),seq(1,nbEnsemble,by = 1))
}
modelsSVR <- list()
predictedYAll <- list()
tunedModelYAll <- list()
pb <- progress_bar$new(
format = "Training SVR on subsets [:bar] :percent in :elapsed",
total = nbEnsemble, clear = FALSE, width= 100)
i = 1
TrainingSet <- list()
TrainingSet$X <- BRF_LUT[Subsets[i][[1]],]
TrainingSet$Y <- InputVar[Subsets[i][[1]]]
TrainingSet$X
TrainingSet$Y
reset.warnings()
library(expandFunctions)
reset.warnings()
tunedModel <- liquidSVM::svmRegression(TrainingSet$X, TrainingSet$Y)
install.packages('simsalapar')
tryCatch.W.E(tunedModel <- liquidSVM::svmRegression(TrainingSet$X, TrainingSet$Y))
library('simsalapar')
tryCatch.W.E(tunedModel <- liquidSVM::svmRegression(TrainingSet$X, TrainingSet$Y))
r1 <- tryCatch.W.E(tunedModel <- liquidSVM::svmRegression(TrainingSet$X, TrainingSet$Y))
r1
r1$warning
r2 <- tryCatch.W.E(x <- 12)
r2
r1 <- tryCatch.W.E(tunedModel <- liquidSVM::svmRegression(TrainingSet$X, TrainingSet$Y))
(!is.null(r1$warning))
Msg <- names(warnings())
Msg
reset.warnings()
r1 <- tryCatch.W.E(tunedModel <- liquidSVM::svmRegression(TrainingSet$X, TrainingSet$Y))
(!is.null(r1$warning))
Msg <- names(warnings())
Msg
r1$warning
Msg <- r1$warning
Msg
ValGamma <- str_split(string = Msg,pattern = 'gamma=')[[1]][2]
ValLambda <- str_split(string = Msg,pattern = 'lambda=')[[1]][2]
library(stringr)
ValGamma <- str_split(string = Msg,pattern = 'gamma=')[[1]][2]
Msg
Msg$message
r1$warning$call
Msg <- r1$warning$message
ValGamma <- str_split(string = Msg,pattern = 'gamma=')[[1]][2]
ValLambda <- str_split(string = Msg,pattern = 'lambda=')[[1]][2]
ValLambda
ValGamma
detach("package:prosail", unload = TRUE)
library(prosail)
library(prosail)
library(prosail)
################################################################################
# This program aims at downloading and processing Sentinel-2 data
# This includes processing of S2 data
# - download full tile with sen2r
# - Crop, resample using interpolation, stack
# - compute spectral indices
# - Compute biophysical variables using PROSAIL inversion
################################################################################
rm(list=ls(all=TRUE));gc()
# Loading libraries
library(sen2r)
library(preprocS2)
########################################################################
##                      Download S2 data with sen2r                   ##
########################################################################
# get product name corresponding to Barrax
dateAcq <- '2021-05-13'
time_window <- as.Date(c(dateAcq, dateAcq))
path_vector <- 'D:/DEPOTS/01_MY_PACKAGES/preprocS2/DATA/Study_area_Barrax.shp'
list_safe <- s2_list(spatial_extent = sf::st_read(dsn = path_vector), time_interval = time_window)
DirWrite <- 'D:/DEPOTS/01_MY_PACKAGES/preprocS2/DATA'
Path_S2 <- file.path(DirWrite,list.files(DirWrite,pattern = '.SAFE'))
# Result directory
result_path <- '../RESULTS'
dir.create(path = result_path,showWarnings = FALSE,recursive = TRUE)
##____________________________________________________________________##
##                  Extract, resample & stack data                    ##
# define resolution
resolution <- 10
# define source of data
S2source <- 'SAFE'
S2obj <- preprocS2::extract_from_S2_L2A(Path_dir_S2 = Path_S2,
path_vector = path_vector,
S2source = S2source,
resolution = resolution)
# update shapefile if needed (reprojection)
path_vector <- S2obj$path_vector
########################################################################
##                  Write CLOUD MASK & REFLECTANCE                    ##
########################################################################
# create specific result directory corresponding to granule name
results_site_path <- file.path(result_path,basename(S2obj$S2_Bands$GRANULE))
dir.create(path = results_site_path,showWarnings = FALSE,recursive = TRUE)
##____________________________________________________________________##
##                        Write CLOUD MASK                            ##
##--------------------------------------------------------------------##
# directory for cloud mask
Cloud_path <- file.path(results_site_path,'CloudMask')
dir.create(path = Cloud_path,showWarnings = FALSE,recursive = TRUE)
# Filename for cloud mask
cloudmasks <- preprocS2::save_cloud_s2(S2_stars = S2obj$S2_Stack,
Cloud_path = Cloud_path,
S2source = S2source, SaveRaw = T)
##____________________________________________________________________##
##                        Write REFLECTANCE                           ##
##--------------------------------------------------------------------##
# directory for Reflectance
Refl_dir <- file.path(results_site_path,'Reflectance')
dir.create(path = Refl_dir,showWarnings = FALSE,recursive = TRUE)
# filename for Reflectance
Refl_path <- file.path(Refl_dir,paste(basename(S2obj$S2_Bands$GRANULE),'_Refl',sep = ''))
# Save Reflectance file as ENVI image with BIL interleaves
tileS2 <- substring(strsplit(basename(S2obj$S2_Bands$GRANULE),'_')[[1]][2],2)
dateAcqS2 <- as.Date(substring(strsplit(basename(S2obj$S2_Bands$GRANULE),'_')[[1]][4],1,8),format="%Y%m%d")
preprocS2::save_reflectance_s2(S2_stars = S2obj$S2_Stack, Refl_path = Refl_path,
S2Sat = NULL, tileS2 = tileS2, dateAcqS2 = dateAcqS2,
Format = 'ENVI_BIL', datatype = 'INT2S', MTD = S2obj$S2_Bands$metadata)
########################################################################
##                      COMPUTE SPECTRAL INDEX                        ##
########################################################################
library(prosail)
library(raster)
library(stars)
# Read raster
Refl <- brick(Refl_path)
# get raster band name and clean format. Expecting band name and wavelength to be documented in image
HDR_Refl <- read_ENVI_header(get_HDR_name(Refl_path))
SensorBands <- HDR_Refl$wavelength
# compute a set of spectral indices defined by IndexList from S2 data
IndexList <- c('EVI','NDVI','CR_SWIR', 'MCARI','NDWI1','mNDVI705')
# ReflFactor = 10000 when reflectance is coded as INT16
Indices <- prosail::ComputeSpectralIndices_Raster(Refl = Refl, SensorBands = SensorBands,
Sel_Indices = IndexList,
ReflFactor = 10000, StackOut=F)
# create directory for Spectral indices
SI_path <- file.path(results_site_path,'SpectralIndices')
dir.create(path = SI_path,showWarnings = FALSE,recursive = TRUE)
# Save spectral indices
for (SpIndx in names(Indices$SpectralIndices)){
Index_Path <- file.path(SI_path,paste(basename(S2obj$S2_Bands$GRANULE),'_',SpIndx,sep = ''))
stars::write_stars(st_as_stars(Indices$SpectralIndices[[SpIndx]]), dsn=Index_Path, driver =  "ENVI",type='Float32')
# write band name in HDR
HDR <- read_ENVI_header(get_HDR_name(Index_Path))
HDR$`band names` <- SpIndx
write_ENVI_header(HDR = HDR,HDRpath = get_HDR_name(Index_Path))
}
########################################################################
##      COMPUTE BIOPHYSICAL VARIABLES BASED ON PROSAIL INVERSION      ##
########################################################################
# Update Cloud mask based on radiometric filtering
# eliminate pixels with NDVI < NDVI_Thresh because not enough vegetation
NDVI_Thresh <- 0.5
Elim <- which(values(Indices$SpectralIndices[['NDVI']])<NDVI_Thresh)
CloudInit <- stars::read_stars(cloudmasks$BinaryMask)
CloudInit$CloudMask_Binary[Elim] <- 0
# save updated cloud mask
Cloud_File <- file.path(Cloud_path,'CloudMask_Binary_Update')
stars::write_stars(CloudInit, dsn=Cloud_File,driver = "ENVI",type='Byte')
# get S2 geometry
# read metadata file from S2 image
xmlfile <- file.path(dirname(Refl_path),'MTD_TL.xml')
S2Geom <- get_S2geometry(MTD_TL_xml = xmlfile)
# Train PROSAIL inversion
minval <- data.frame('CHL'=10,'CAR'=0,'EWT' = 0.005,'ANT' = 0,'LMA' = 0.005,'N' = 1.5,'psoil' = 0.0, 'BROWN'=0.0,
'LIDFa' = 50, 'lai' = 0.5,'q'=0.1,'tto' = 0,'tts' = min(S2Geom$SZA), 'psi' = 5)
maxval <- data.frame('CHL'=90,'CAR'=20,'EWT' = 0.03,'ANT' = 3,'LMA' = 0.03,'N' = 2.0, 'psoil' = 1.0, 'BROWN'=0.5,
'LIDFa' = 70, 'lai' = 7,'q'=0.2,'tto' = 7,'tts' = max(S2Geom$SZA), 'psi' = 355)
# get sensor response for Sentinel-2
SensorName <- HDR_Refl$`sensor type`
SRF <- GetRadiometry(SensorName,Path_SensorResponse = NULL)
# adjust optical constants from 1nm sampling into spectral S2 spectral sampling
wvl <- SpecPROSPECT$lambda
SpecSensor <- PrepareSensorSimulation(SpecPROSPECT,SpecSOIL,SpecATM,SRF)
SpecPROSPECT_Sensor <- SpecSensor[[1]]$SpecPROSPECT_Sensor
SpecSOIL_Sensor <- SpecSensor[[1]]$SpecSOIL_Sensor
SpecATM_Sensor <- SpecSensor[[1]]$SpecATM_Sensor
# define spectral bands required to train SVR model for each variable
S2BandSelect <- list()
S2BandSelect$CHL <- S2BandSelect$lai <- S2BandSelect$EWT <- S2BandSelect$LMA <- c('B03','B04','B05','B06','B07','B08','B11','B12')
ImgBandNames <- strsplit(HDR_Refl$`band names`,split = ',')[[1]]
# get variable ID for train_prosail_inversion
Bands2Select <- list()
for (bpvar in names(S2BandSelect)){
Bands2Select[[bpvar]] <- match(S2BandSelect[[bpvar]],ImgBandNames)
}
# define noise level for each variable
NoiseLevel <- list()
NoiseLevel$EWT <- 0.025
NoiseLevel$CHL <- 0.01
NoiseLevel$LMA <- NoiseLevel$lai <- 0.05
# where results will be stored
PROSAIL_ResPath <- file.path(results_site_path,'PROSAIL_INVERSION_4SAIL')
dir.create(path = PROSAIL_ResPath,showWarnings = FALSE,recursive = TRUE)
modelSVR <- train_prosail_inversion(minval=minval,maxval=maxval,Parms2Estimate=c('CHL','EWT','LMA','lai'),
Bands2Select=Bands2Select,NoiseLevel=NoiseLevel,
SpecPROSPECT = SpecPROSPECT_Sensor, SpecSOIL = SpecSOIL_Sensor, SpecATM = SpecATM_Sensor,
Path_Results=PROSAIL_ResPath,nbModels = 10,nbSamples = 1000,FigPlot = FALSE)
# Apply SVR model on Sentinel-2 data
Apply_prosail_inversion(raster_path = Refl_path, HybridModel = modelSVR, PathOut = PROSAIL_ResPath,
SelectedBands = S2BandSelect,bandname = ImgBandNames,
MaskRaster = Cloud_File, MultiplyingFactor = 10000)
detach("package:prosail", unload = TRUE)
library(prosail)
# Apply SVR model on Sentinel-2 data
Apply_prosail_inversion(raster_path = Refl_path, HybridModel = modelSVR, PathOut = PROSAIL_ResPath,
SelectedBands = S2BandSelect,bandname = ImgBandNames,
MaskRaster = Cloud_File, MultiplyingFactor = 10000)
